# マルチテナント認証・認可システム - 管理者登録フロー（統合版）

**対象システム**: 全社共通LLMゲートウェイ | **想定規模**: 8,000名 × 100部門（テナント） | **作成日**: 2025-12-11

## アーキテクチャの前提

- **テナント = 部門 = Entra ID セキュリティグループ**: 営業部（SG-Sales）、マーケ部（SG-Marketing）等
- **Cognitoグループ**: 各部門に対して `Admin-{SecurityGroup}` と `User-{SecurityGroup}` を動的作成
- **権限管理**: Cognito側で管理者/一般ユーザーを区別（Entra IDからは所属部門のみ受信）
- **JWT自動セット**: Cognitoが `cognito:groups` に所属グループを自動的に含める（開発不要）

---

## 🏢 全社共通LLMゲートウェイ基盤のアーキテクチャ

### システム全体像

本システムは、**マルチテナントリゾルバ**と**LLMゲートウェイ**の2つの中核機能で構成される、全社共通LLM基盤です。

```
┌─────────────────────────────────────────────────────────────────────┐
│                    全社共通LLMゲートウェイ基盤                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  ┌──────────────────────┐         ┌─────────────────────────────┐  │
│  │マルチテナントリゾルバ │   →     │    LLMゲートウェイ          │  │
│  ├──────────────────────┤         ├─────────────────────────────┤  │
│  │・SSO認証             │         │・Bedrock統合API             │  │
│  │・テナントID解決      │         │・ナレッジベース統合API      │  │
│  │・JWT発行             │         │・テナント別フィルタリング   │  │
│  │・権限管理            │         │・モデルルーティング         │  │
│  └──────────────────────┘         │・ガバナンス制御             │  │
│           │                        └─────────────────────────────┘  │
│           │                                     │                    │
│           ▼                                     ▼                    │
│  【テナントID (部門ID)】            【統合ログ + ガードレール】    │
│   例: SG-Sales, SG-Marketing        全リクエストにテナントID埋込   │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 🔐 マルチテナントリゾルバ

### 機能概要

マルチテナントリゾルバは、**ユーザーが所属するテナント（部門）を自動的に識別**し、後続のLLMゲートウェイに渡す役割を担います。

| 項目 | 内容 |
|------|------|
| **目的** | SSO認証後、ユーザーの所属テナント（部門）を特定し、JWT内に `cognito:groups` として埋め込む |
| **入力** | Entra ID SAML Assertion（所属セキュリティグループ: SG-Sales等） |
| **処理** | 1. SAML認証成功<br>2. Cognito User Pool にユーザー作成<br>3. セキュリティグループから対応するCognitoグループを判定<br>4. `Admin-{SecurityGroup}` または `User-{SecurityGroup}` に割り当て |
| **出力** | JWT（ID Token）に `cognito:groups: ["Admin-SG-Sales"]` または `["User-SG-Sales"]` を含める |
| **後続処理への連携** | チャットアプリがこのJWTをAPIリクエストのAuthorizationヘッダーに付与→LLMゲートウェイがテナントIDを抽出 |

### テナントID解決フロー

```
1. ユーザー操作: ブラウザで https://llm-gateway.isuzu.co.jp にアクセス

2. SSO認証: Cognito Hosted UI → Entra ID 認証成功
   → SAML Assertion 返却（所属: SG-Sales）

3. マルチテナントリゾルバ処理:
   - Cognito User Pool にユーザー自動作成（sato@isuzu.co.jp）
   - セキュリティグループ（SG-Sales）から Cognito グループ判定: User-SG-Sales
   - JWT発行: cognito:groups=["User-SG-Sales"], custom:tenantId="SG-Sales"

4. チャットアプリ起動:
   - JWT を LocalStorage に保存 → テナントID "SG-Sales" 抽出
   - 画面表示: "営業部のRAGチャット"

5. LLMゲートウェイ連携:
   - 全API呼び出しに Authorization: Bearer {JWT} 付与
   - LLMゲートウェイが JWT からテナントID "SG-Sales" を抽出
```

---

## 🌐 LLMゲートウェイ

### 機能概要

LLMゲートウェイは、**単一の統合APIを提供**することで、チャットアプリとLLMサービス（Bedrock、ナレッジベース）を**疎結合**に保ち、**ガバナンス制御**を一元化します。

### アーキテクチャコンセプト

```
┌────────────────────────────────────────────────────────────────┐
│                     チャットアプリ（React SPA）                  │
│  ・ユーザーは単一のAPIエンドポイントのみを知る                    │
│  ・LLMの種類、ナレッジベースの実装詳細を知らない（疎結合）         │
└────────────────────────────────────────────────────────────────┘
                              │
                              │ POST /api/chat
                              │ Authorization: Bearer {JWT}
                              │ Body: { message: "質問", model: "claude-3-5-sonnet" }
                              ▼
┌────────────────────────────────────────────────────────────────┐
│                      LLMゲートウェイ                             │
│                     (API Gateway + Lambda)                       │
├────────────────────────────────────────────────────────────────┤
│ 【1. JWT検証・テナントID抽出】                                   │
│   ├─ Cognito Authorizer でJWT検証                              │
│   ├─ cognito:groups から "User-SG-Sales" を抽出                │
│   └─ テナントID "SG-Sales" を特定                              │
│                                                                  │
│ 【2. ガバナンス制御】                                            │
│   ├─ CloudWatch Logs に以下を記録:                             │
│   │   - テナントID: "SG-Sales"                                 │
│   │   - ユーザーID: "sato@isuzu.co.jp"                         │
│   │   - リクエスト時刻、モデル名、トークン数                    │
│   ├─ 将来拡張: Guardrails for Amazon Bedrock                   │
│   │   └─ テナント別ガードレール設定を容易に適用可能              │
│   └─ コスト配賦: テナントID別トークン使用量を集計               │
│                                                                  │
│ 【3. ゲートウェイ・ルーティング】                                │
│   ├─ モデルルーティング:                                        │
│   │   └─ UIで指定されたモデル名（claude-3-5-sonnet等）を        │
│   │       Bedrock InvokeModel APIの引数として使用               │
│   │                                                              │
│   └─ ナレッジベースフィルタリング:                               │
│       ├─ Bedrock Retrieve API 呼び出し時に                     │
│       │   retrievalConfiguration.vectorSearchConfiguration      │
│       │   .filter = { "equals": { "key": "department",         │
│       │                          "value": "SG-Sales" } }        │
│       └─ 結果: 営業部（SG-Sales）のドキュメントのみ取得         │
└────────────────────────────────────────────────────────────────┘
                    │                          │
                    ▼                          ▼
        ┌─────────────────────┐   ┌──────────────────────────┐
        │ Amazon Bedrock      │   │ Bedrock Knowledge Base   │
        │ (Claude, Titan等)   │   │ (Aurora PostgreSQL)      │
        └─────────────────────┘   └──────────────────────────┘
```

### 提供API仕様

| API | 機能 | リクエスト例 | レスポンス |
|-----|------|------------|-----------|
| **POST /api/chat** | RAGチャット | `{ "message": "売上レポート", "model": "claude-3-5-sonnet" }`<br>Header: `Authorization: Bearer {JWT}` | ストリーミングレスポンス（SSE）<br>`{ "answer": "...", "sources": [...] }` |
| **POST /api/bedrock/invoke** | Bedrock直接呼び出し | `{ "prompt": "要約して", "model": "claude-3-haiku" }`<br>Header: `Authorization: Bearer {JWT}` | `{ "completion": "..." }` |
| **GET /api/documents** | ドキュメント一覧取得 | Header: `Authorization: Bearer {JWT}` | `[{ "id": "...", "title": "...", "department": "SG-Sales" }]` |

### ゲートウェイ実装例（Lambda）

```typescript
// Lambda: ChatGateway
export const handler = async (event: APIGatewayProxyEvent) => {
  // 1. JWT検証・テナントID抽出
  const claims = event.requestContext.authorizer!.claims;
  const groups = claims['cognito:groups'] || [];
  const tenantId = extractTenantId(groups); // "SG-Sales"
  const userId = claims['email'];

  // 2. リクエスト解析
  const { message, model } = JSON.parse(event.body!);

  // 3. ガバナンスログ記録
  console.log(JSON.stringify({
    timestamp: new Date().toISOString(),
    tenantId,           // ← テナントID埋め込み
    userId,
    action: 'chat',
    model,
    message: message.substring(0, 100), // プレビュー
  }));

  // 4. ナレッジベース検索（テナントフィルタリング）
  const retrieveResponse = await bedrock.send(new RetrieveCommand({
    knowledgeBaseId: process.env.KB_ID,
    retrievalQuery: { text: message },
    retrievalConfiguration: {
      vectorSearchConfiguration: {
        numberOfResults: 5,
        filter: {
          equals: {
            key: 'department',
            value: tenantId,  // ← テナント別フィルタリング
          },
        },
      },
    },
  }));

  // 5. Bedrock呼び出し（モデルルーティング）
  const invokeResponse = await bedrock.send(new InvokeModelCommand({
    modelId: model,  // ← UIで指定されたモデルを使用
    body: JSON.stringify({
      anthropic_version: 'bedrock-2023-05-31',
      messages: [{ role: 'user', content: message }],
      system: buildSystemPrompt(retrieveResponse.retrievalResults),
    }),
  }));

  // 6. トークン使用量記録（コスト配賦用）
  const usage = JSON.parse(invokeResponse.body).usage;
  console.log(JSON.stringify({
    timestamp: new Date().toISOString(),
    tenantId,           // ← テナントID埋め込み
    userId,
    model,
    inputTokens: usage.input_tokens,
    outputTokens: usage.output_tokens,
  }));

  return { statusCode: 200, body: JSON.stringify({ answer: '...' }) };
};
```

---

## 📊 ガバナンス機能

### テナントID埋め込みによる統制

| ガバナンス項目 | 実装内容 |
|--------------|---------|
| **ログ統制** | すべてのAPI呼び出しログに `tenantId` フィールドを埋め込み<br>→ CloudWatch Logs Insights でテナント別分析が可能<br>例: `fields @timestamp, tenantId, userId, model, inputTokens \| filter tenantId = "SG-Sales"` |
| **コスト配賦** | CloudWatch Logs → Metric Filter → CloudWatch Metrics<br>→ テナント別トークン使用量を自動集計<br>→ 部門別のLLM利用コストを可視化 |
| **アクセス制御** | JWTの `cognito:groups` を検証し、テナント外のリソースへのアクセスを拒否<br>例: User-SG-Sales は SG-Marketing のドキュメントにアクセス不可 |
| **監査証跡** | すべてのリクエスト・レスポンスをテナントIDと紐付けて保存<br>→ コンプライアンス監査に対応 |

### 将来拡張: テナント別ガードレール

```typescript
// 将来実装例: テナント別ガードレール設定
const guardrailConfig = await getGuardrailConfig(tenantId);

if (guardrailConfig.enabled) {
  const applyGuardrailResponse = await bedrock.send(new ApplyGuardrailCommand({
    guardrailIdentifier: guardrailConfig.guardrailId,
    guardrailVersion: guardrailConfig.version,
    source: 'INPUT',
    content: [{ text: { text: message } }],
  }));

  if (applyGuardrailResponse.action === 'GUARDRAIL_INTERVENED') {
    // ガードレール違反: リクエスト拒否
    return {
      statusCode: 400,
      body: JSON.stringify({
        error: 'このリクエストは部門のガードレールポリシーに違反しています',
        details: applyGuardrailResponse.assessments,
      }),
    };
  }
}
```

### テナント別ガードレール設定例

| テナント | 制限内容 | 設定値 |
|---------|---------|-------|
| **SG-Sales（営業部）** | ・顧客情報の漏洩防止<br>・競合他社名の出力制限 | Guardrail ID: `営業部専用ガードレール`<br>- Sensitive Information Filter: 有効<br>- Denied Topics: ["競合情報"] |
| **SG-Legal（法務部）** | ・法的助言の禁止<br>・機密性の高い契約情報の保護 | Guardrail ID: `法務部専用ガードレール`<br>- Content Filter: 高<br>- Denied Topics: ["法的助言"] |
| **SG-HR（人事部）** | ・個人情報保護<br>・給与・評価情報の制限 | Guardrail ID: `人事部専用ガードレール`<br>- PII Redaction: 有効<br>- Denied Topics: ["給与", "評価"] |

---

## 🎯 全社共通基盤としての価値

### 疎結合アーキテクチャによる柔軟性

| メリット | 説明 |
|---------|------|
| **LLMモデルの変更が容易** | チャットアプリは単一のAPIエンドポイントを呼ぶだけ。LLMゲートウェイ側でモデルを切り替えても、フロントエンド変更不要。 |
| **ナレッジベース実装の変更が容易** | 現在はAurora PostgreSQL（pgvector）を使用しているが、将来OpenSearch Serverlessに移行しても、API仕様は変わらない。 |
| **新機能の段階的展開** | 特定テナントのみで新しいガードレールや機能を試験運用し、全社展開前に検証可能。 |

### ガバナンス一元化による統制

| メリット | 説明 |
|---------|------|
| **コンプライアンス対応** | すべてのLLM利用がゲートウェイを経由するため、監査証跡が完全。 |
| **コスト可視化** | テナント別・ユーザー別・モデル別のトークン使用量を自動集計。 |
| **セキュリティ統制** | ガードレール、アクセス制御、データフィルタリングをゲートウェイで一元管理。 |

---

## 📋 推奨フロー（マルチテナントリゾルバの文脈）

### ステップ0: 部門（テナント）の作成
```
1. システム管理者が管理画面で「新規部門作成」をクリック
2. 部門名（Entra IDのセキュリティグループ名）を入力: SG-Sales
3. 「作成」ボタンをクリック
   ↓ システムが自動処理
4. Cognitoグループ作成: Admin-SG-Sales（管理者用）
5. Cognitoグループ作成: User-SG-Sales（一般ユーザー用）
6. IAM Role 紐付け（それぞれのグループに適切な権限を設定）
```

### ステップ1: 部門管理者の登録
```
1. 管理画面で tanaka@isuzu.co.jp を SG-Sales（営業部）の管理者として登録
2. システムが S3 に JSON ファイル保存（s3://pending-assignments/tanaka@isuzu.co.jp.json）
   - groups: ["Admin-SG-Sales"]
3. 画面に「登録完了。ログインURLを共有してください」と表示
4. 業務メールで田中さんに通知（手動 or SES自動送信）
```

### ステップ2: 田中さん（部門管理者）の初回ログイン
```
1. メール受信 → URLクリック（https://llm-gateway.isuzu.co.jp）
2. 「Entra ID でログイン」ボタンをクリック
3. Entra ID で認証（既存アカウント・既存パスワード使用）
   ※ Entra IDから所属セキュリティグループ（SG-Sales）が渡される
4. 【自動処理】Cognito User Pool にユーザー自動作成
5. 【自動処理】Post Authentication Trigger 実行
   - S3 から JSON 読み取り → Admin-SG-Sales グループに追加 → S3 削除
6. 【自動処理】JWT発行（cognito:groups: ["Admin-SG-Sales"] を自動セット）
7. 管理画面が表示（管理者権限付与完了）
   ※ フロントエンドがJWTから管理者権限を判定
```

---

## 🔄 処理フロー詳細

### ステップ1: システム管理者が部門管理者を登録（未ログインユーザーの場合）

**前提**: 部門（SG-Sales）は既に作成済み（ステップ0で作成）

| No | 処理内容 | AWSサービス | SI開発要否 | 開発内容 | カテゴリ | 使用技術 | 工数 |
|----|---------|-----------|----------|---------|---------|---------|------|
| 1.1 | 管理者情報の入力と登録 | - | ✅ **開発必要** | **管理画面UI実装**<br>- メールアドレス入力フォーム作成<br>- 管理対象部門の選択UI（ドロップダウン: SG-Sales, SG-Marketing等）<br>- メール形式バリデーション<br>- 登録ボタンクリックイベント処理 | 管理画面UI<br>（システム管理者） | React<br>TypeScript<br>Material-UI | 3人日 |
| 1.2 | グループ割当処理 | API Gateway<br>Lambda<br>Cognito User Pool<br>S3 | ✅ **開発必要** | **バックエンド実装（Lambda + インフラ）**<br>- 前提: 部門作成時に以下の2つのCognitoグループが作成済み<br>  - Admin-{SecurityGroup}（管理者用）<br>  - User-{SecurityGroup}（一般ユーザー用）<br>- Lambda: ユーザー存在確認と処理分岐<br>- 既存ユーザー: 直接Admin-{SecurityGroup}に追加<br>- 未ログインユーザー: S3に保留情報を保存<br>- S3バケット作成と30日自動削除ポリシー設定 | API Gateway<br>+<br>Lambda<br>AssignPendingGroup<br>+<br>インフラ（CDK）<br>S3 | CDK<br>TypeScript<br>AWS SDK | 10人日 |
| 1.3 | 登録完了通知 | - | ✅ **開発必要** | **Lambda + フロントエンド実装**<br>- Lambda: JSON形式でステータス返却<br>- 画面: レスポンス受信後にトースト通知表示<br>- 「初回ログイン時に自動適用」メッセージ | Lambda + 管理画面UI | TypeScript<br>React | 含む |

**ステップ1 小計**: 管理画面UI 3人日 + バックエンド処理 10人日 = **13人日**

---

### ステップ2: 田中さんが初回ログイン

| No | 処理内容 | AWSサービス | SI開発要否 | 開発内容 | カテゴリ | 使用技術 | 工数 |
|----|---------|-----------|----------|---------|---------|---------|------|
| 2.1 | ログイン画面表示 | CloudFront<br>ALB, ECS<br>Cognito Hosted UI | ✅ / ❌ | **フロントエンド実装 + 設定**<br>- ログインページ作成とCognito Hosted UIへのリダイレクト処理<br>- Hosted UIのカスタマイズ（ロゴ・背景色） | 管理画面UI | React<br>TypeScript | 2人日 |
| 2.2 | SAML認証 | Entra ID (SAML) | ❌ **顧客側設定** | **設定作業のみ**<br>- Entra ID と Cognito 間のSAML連携設定<br>- メタデータXML交換<br>- 属性マッピング設定（email, name, セキュリティグループ等）<br>※ Entra IDから所属セキュリティグループ（SG-Sales等）が渡される | - | - | - |
| 2.3 | ユーザー自動作成 | Cognito User Pool | ❌ **AWS標準** | AWS標準機能（開発不要）<br>※ SAML認証成功時にCognitoが自動的にユーザー作成 | - | - | - |
| 2.4 | 保留情報の取得 | Lambda<br>(Cognito Trigger) | ✅ **開発必要** | **Lambda関数実装 + インフラ構築**<br>- S3から保留ファイル取得（メールアドレスをキーに検索）<br>- JSONデータのパース（例: ["Admin-SG-Sales"]）<br>- NoSuchKey例外のハンドリング<br>- Cognito Triggerの設定 | Lambda<br>PostAuthentication | TypeScript<br>AWS SDK | 3人日 |
| 2.5 | グループ自動追加 | Cognito User Pool<br>S3 | ✅ **開発必要** | **Lambda関数実装**<br>- 取得したグループリスト（例: Admin-SG-Sales）をループ処理<br>- 各グループにユーザーを追加<br>- 処理完了後にS3ファイルを削除<br>- エラーログ出力 | Lambda<br>PostAuthentication | TypeScript<br>AWS SDK | 2人日 |
| 2.6 | JWT発行 | Cognito User Pool | ❌ **AWS標準** | **AWS標準機能（開発不要）**<br>※ Cognitoが自動的に `cognito:groups` にグループ情報をセット<br>例: `{"cognito:groups": ["Admin-SG-Sales"]}` | - | - | - |
| 2.7 | トークン取得と画面表示 | - | ✅ **開発必要** | **フロントエンド実装**<br>- コールバックURLでAuthorization Code受信<br>- Token エンドポイントへPOSTリクエスト<br>- 取得したToken をLocalStorageに保存<br>- JWTから管理者権限を判定（cognito:groupsを参照）<br>- ホーム画面へリダイレクト処理 | 管理画面UI | React<br>TypeScript | 3人日 |

**ステップ2 小計**: 管理画面UI 5人日 + Lambda (PostAuthentication) 5人日 = **10人日**

---

### ステップ3: 部門管理者が一般ユーザーを登録

| No | 処理内容 | AWSサービス | SI開発要否 | 開発内容 | カテゴリ | 使用技術 | 工数 |
|----|---------|-----------|----------|---------|---------|---------|------|
| 3.1 | ユーザー管理画面 | Cognito Identity Pool<br>Cognito User Pool | ✅ **開発必要** | **フロントエンド実装**<br>- 「ユーザー管理」メニューの表示制御（管理者のみ）<br>- Identity Pool から一時認証情報を取得<br>- AdminListUsersInGroup API でユーザー一覧取得<br>- ユーザー一覧のテーブル表示UI<br>- ページネーション実装 | 管理画面UI<br>（部門管理者） | React<br>TypeScript<br>AWS SDK | 7人日 |
| 3.2 | ユーザー追加 | API Gateway<br>Lambda | ✅ **開発必要** | **フロントエンド実装**<br>- メールアドレス入力フォーム<br>- バリデーション処理<br>- API呼び出し（既存AssignPendingGroup再利用）<br>- 追加完了後のユーザー一覧再読み込み | 管理画面UI<br>（部門管理者） | React<br>TypeScript | 5人日 |
| 3.3 | 一般ユーザーへのメール通知 | Lambda<br>Amazon SES | ✅ **開発必要** | **Lambda + SES実装**<br>- ユーザー追加成功後に自動メール送信<br>- メールテンプレート作成（ログインURL含む）<br>- 送信ドメイン認証設定<br>※ 一般ユーザーはメール受信後、URL（https://llm-gateway.isuzu.co.jp）をクリックしてEntra ID認証を行い、初回ログイン時に自動的にUser-{SecurityGroup}に追加される | Lambda<br>SendNotification | TypeScript<br>AWS SDK<br>SES | 3人日 |

**ステップ3 小計**: 管理画面UI（部門管理者）12人日 + メール通知 3人日 = **15人日**

---

### ステップ0: 部門（テナント）作成機能

| No | 処理内容 | AWSサービス | SI開発要否 | 開発内容 | カテゴリ | 使用技術 | 工数 |
|----|---------|-----------|----------|---------|---------|---------|------|
| 0.1 | 部門作成UI | - | ✅ **開発必要** | **管理画面UI実装**<br>- 部門名入力フォーム（例: SG-Sales）<br>- 作成ボタンクリック処理<br>- バリデーション（重複チェック） | 管理画面UI<br>（システム管理者） | React<br>TypeScript | 2人日 |
| 0.2 | Cognitoグループ動的作成 | Lambda<br>Cognito User Pool | ✅ **開発必要** | **Lambda関数実装**<br>- Cognitoグループ作成（Admin-{SecurityGroup}）<br>- Cognitoグループ作成（User-{SecurityGroup}）<br>- IAM Role紐付け<br>- エラーハンドリング（既存グループ重複） | Lambda<br>CreateTenant | TypeScript<br>AWS SDK | 5人日 |

**ステップ0 小計**: **7人日**

### インフラ（Cognito初期設定）

| 項目 | 内容 | SI開発要否 | 開発内容 | カテゴリ | 使用技術 | 工数 |
|------|------|----------|---------|---------|---------|------|
| Cognito 初期設定 | - User Pool 作成<br>- SystemAdmin グループ作成<br>- IAM Role 定義<br>- SAML Identity Provider 設定<br>- User Pool Client 設定<br>- Identity Pool 作成 | ✅ **開発必要** | **インフラ構築**<br>- Cognito User Pool の作成<br>- SystemAdmin グループ作成（初期グループ）<br>- 管理者用/一般ユーザー用 IAM Role定義<br>- SAML Identity Provider（Entra ID）設定<br>- OAuth 2.0 設定（Authorization Code Flow）<br>- Identity Pool作成とRole Attachment設定<br>※ 部門別グループ（Admin-*, User-*）は動的作成 | インフラ（CDK）<br>Cognito | CDK<br>TypeScript | 8人日 |

---

## 📊 開発工数まとめ

| カテゴリ | 開発要素 | 使用技術 | 工数見積 |
|---------|---------|---------|---------|
| **管理画面UI（システム管理者）** | - 部門作成UI<br>- 部門管理者登録<br>- メール入力フォーム<br>- 部門選択 | React, TypeScript, Material-UI | **12人日** |
| **管理画面UI（部門管理者）** | - ユーザー一覧表示<br>- 新規ユーザー追加<br>- Identity Pool 連携 | React, TypeScript, AWS SDK | **12人日** |
| **Lambda（CreateTenant）** | - Cognitoグループ動的作成<br>- IAM Role 紐付け | TypeScript, AWS SDK | **5人日** |
| **Lambda（AssignPendingGroup）** | - Cognito 存在確認<br>- S3 保存/直接追加分岐 | TypeScript, AWS SDK | **5人日** |
| **Lambda（PostAuthentication）** | - S3 読み取り<br>- グループ自動追加<br>- S3 削除 | TypeScript, AWS SDK | **5人日** |
| **Lambda（SendNotification）** | - メール送信<br>- メールテンプレート<br>- SES設定 | TypeScript, AWS SDK, SES | **3人日** |
| **インフラ（CDK）- S3** | - pending-assignments バケット<br>- ライフサイクルポリシー | CDK (TypeScript) | **2人日** |
| **インフラ（CDK）- API Gateway** | - エンドポイント定義<br>- Cognito Authorizer | CDK (TypeScript) | **3人日** |
| **インフラ（CDK）- Cognito** | - User Pool<br>- SystemAdmin グループ<br>- IAM Role マッピング<br>- SAML 連携<br>※部門別グループは動的作成 | CDK (TypeScript) | **8人日** |

**合計**: **約55人日**（管理者・一般ユーザー登録機能、メール通知含む）

---

## 🔐 重要ポイント

| 項目 | 内容 |
|------|------|
| **テナント管理** | 部門 = Entra IDセキュリティグループ = テナントID<br>例: 営業部（SG-Sales）、マーケ部（SG-Marketing） |
| **Cognitoグループ** | 各部門に対して `Admin-{SecurityGroup}` と `User-{SecurityGroup}` を動的作成<br>例: Admin-SG-Sales, User-SG-Sales |
| **権限管理** | Cognito側で管理者/一般ユーザーを区別（Entra IDからは所属部門のみ受信） |
| **JWT自動セット** | ✅ Cognitoが `cognito:groups` に所属グループを自動的に含める（開発不要）<br>例: `{"cognito:groups": ["Admin-SG-Sales", "User-SG-Marketing"]}` |
| **管理者判定** | フロントエンドでJWTの `cognito:groups` から判定（API不要）<br>`groups.filter(g => g.startsWith('Admin-'))` |
| **Cognito招待メール** | ❌ **送られません**（Cognitoにユーザーを事前作成していない、SAML連携でパスワード不要） |
| **SAML連携でCognito標準招待メールが使えない理由** | Cognito User Poolには **Native User**（`AdminCreateUser`で事前作成）と **Federated User**（SAML初回ログイン時に自動作成）の2種類が存在。`AdminCreateUser`でNative Userを作成すると、同じメールアドレスでSAMLログインした際に別のFederated Userが自動作成され、**同一人物が2つのアカウント**を持つことになる。グループ割り当てが分離し、正常に動作しない。<br><br>✅ **採用アプローチ**: S3保留 + カスタムメール通知（Lambda + Amazon SES）<br>- Cognitoにユーザーを事前作成しない<br>- S3にグループ割り当て情報を保存<br>- 初回SAML認証時に自動的にFederated User作成 + グループ追加 |
| **新しいパスワード** | ❌ **不要**（Entra IDのパスワードを使用） |
| **権限付与タイミング** | 初回ログイン時に自動（Post Authentication Trigger） |
| **DynamoDB** | ❌ **不使用**（S3 JSON ファイル方式） |
| **S3 ライフサイクル** | 30日で自動削除 |
| **マルチテナント対応** | 1ユーザが複数部門の管理者/一般ユーザーになることが可能 |

---

## 🏗️ AWSネイティブ機能（開発不要）

| 機能 | 使用サービス |
|------|------------|
| SAML 2.0 認証 | Cognito User Pool + Entra ID |
| JWT 発行・検証 | Cognito User Pool |
| OAuth 2.0 Authorization Code Flow | Cognito User Pool |
| グループメンバーシップ管理 | Cognito User Pool |
| IAM Role 一時認証情報発行 | Cognito Identity Pool |

---

## 📈 データフロー図

```
【ステップ0: 部門作成】
[システム管理者] → [React管理画面] → [Lambda: CreateTenant]
                                      ↓
                                [Cognito] グループ作成
                                - Admin-SG-Sales
                                - User-SG-Sales
                                      ↓
                                [IAM Role 紐付け]

【ステップ1: 部門管理者登録】
[システム管理者] → [React管理画面] → [API Gateway] → [Lambda: AssignPendingGroup]
                                           ↓
                                      [Cognito] AdminGetUser → UserNotFoundException
                                           ↓
                                      [S3] tanaka@isuzu.co.jp.json 保存
                                      {
                                        "email": "tanaka@isuzu.co.jp",
                                        "groups": ["Admin-SG-Sales"]
                                      }

【ステップ2: 初回ログイン】
[田中さん] → [Cognito Hosted UI] → [Entra ID SAML認証]
                                      ↓ セキュリティグループ（SG-Sales）を渡す
                                   [Cognito] ユーザー作成
                                      ↓
                                   [Lambda: PostAuthentication (Trigger)]
                                   S3読取 → AdminAddUserToGroup(Admin-SG-Sales) → S3削除
                                      ↓
                                   [JWT発行] ← Cognitoが自動セット
                                   {
                                     "cognito:groups": ["Admin-SG-Sales"],
                                     "email": "tanaka@isuzu.co.jp"
                                   }
                                      ↓
                                   [React管理画面]
                                   JWT解析 → Admin-* 判定 → 管理者メニュー表示
```

---

**作成者**: SI開発チーム | **最終更新**: 2025-12-11 | **バージョン**: 6.0（統合版・A4 1枚）
