# マルチテナント認証・認可システム - 管理者登録フロー（統合版）

**対象システム**: 全社共通LLMゲートウェイ | **想定規模**: 8,000名 × 100部門（テナント） | **作成日**: 2025-12-11

## アーキテクチャの前提

- **テナント = 部門 = Entra ID セキュリティグループ**: 営業部（SG-Sales）、マーケ部（SG-Marketing）等
- **Cognitoグループ**: 各部門に対して `Admin-{SecurityGroup}` と `User-{SecurityGroup}` を動的作成
- **権限管理**: Cognito側で管理者/一般ユーザーを区別（Entra IDからは所属部門のみ受信）
- **JWT自動セット**: Cognitoが `cognito:groups` に所属グループを自動的に含める（開発不要）

---

## 🏢 全社共通LLMゲートウェイ基盤のアーキテクチャ

### システム全体像

本システムは、**マルチテナントリゾルバ**と**LLMゲートウェイ**の2つの中核機能で構成される、全社共通LLM基盤です。

```
┌─────────────────────────────────────────────────────────────────────┐
│                    全社共通LLMゲートウェイ基盤                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  ┌──────────────────────┐         ┌─────────────────────────────┐  │
│  │マルチテナントリゾルバ │   →     │    LLMゲートウェイ          │  │
│  ├──────────────────────┤         ├─────────────────────────────┤  │
│  │・SSO認証             │         │・Bedrock統合API             │  │
│  │・テナントID解決      │         │・ナレッジベース統合API      │  │
│  │・JWT発行             │         │・テナント別フィルタリング   │  │
│  │・権限管理            │         │・モデルルーティング         │  │
│  └──────────────────────┘         │・ガバナンス制御             │  │
│           │                        └─────────────────────────────┘  │
│           │                                     │                    │
│           ▼                                     ▼                    │
│  【テナントID (部門ID)】            【統合ログ + ガードレール】    │
│   例: SG-Sales, SG-Marketing        全リクエストにテナントID埋込   │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 🔐 マルチテナントリゾルバ

### 機能概要

マルチテナントリゾルバは、**ユーザーが所属するテナント（部門）を自動的に識別**し、後続のLLMゲートウェイに渡す役割を担います。

| 項目 | 内容 |
|------|------|
| **目的** | SSO認証後、ユーザーの所属テナント（部門）を特定し、JWT内に `cognito:groups` として埋め込む |
| **入力** | Entra ID SAML Assertion（所属セキュリティグループ: SG-Sales等） |
| **処理** | 1. SAML認証成功<br>2. Cognito User Pool にユーザー作成<br>3. セキュリティグループから対応するCognitoグループを判定<br>4. `Admin-{SecurityGroup}` または `User-{SecurityGroup}` に割り当て |
| **出力** | JWT（ID Token）に `cognito:groups: ["Admin-SG-Sales"]` または `["User-SG-Sales"]` を含める |
| **後続処理への連携** | チャットアプリがこのJWTをAPIリクエストのAuthorizationヘッダーに付与→LLMゲートウェイがテナントIDを抽出 |

### テナントID解決フロー

```
1. ユーザー操作: ブラウザで https://llm-gateway.isuzu.co.jp にアクセス

2. SSO認証: Cognito Hosted UI → Entra ID 認証成功
   → SAML Assertion 返却（所属: SG-Sales）

3. マルチテナントリゾルバ処理:
   - Cognito User Pool にユーザー自動作成（sato@isuzu.co.jp）
   - セキュリティグループ（SG-Sales）から Cognito グループ判定: User-SG-Sales
   - JWT発行: cognito:groups=["User-SG-Sales"], custom:tenantId="SG-Sales"

4. チャットアプリ起動:
   - JWT を LocalStorage に保存 → テナントID "SG-Sales" 抽出
   - 画面表示: "営業部のRAGチャット"

5. LLMゲートウェイ連携:
   - 全API呼び出しに Authorization: Bearer {JWT} 付与
   - LLMゲートウェイが JWT からテナントID "SG-Sales" を抽出
```

---

## 🌐 LLMゲートウェイ

### 機能概要

LLMゲートウェイは、**単一の統合APIを提供**することで、チャットアプリとLLMサービス（Bedrock、ナレッジベース）を**疎結合**に保ち、**ガバナンス制御**を一元化します。

### アーキテクチャコンセプト

```
┌────────────────────────────────────────────────────────────────┐
│  チャットアプリ（React SPA）: 単一APIのみ利用（疎結合）         │
└────────────────────────────────────────────────────────────────┘
            │ POST /api/chat + Authorization: Bearer {JWT}
            ▼
┌────────────────────────────────────────────────────────────────┐
│                 LLMゲートウェイ (API Gateway + Lambda)           │
├────────────────────────────────────────────────────────────────┤
│ 【JWT検証・テナントID抽出】                                      │
│   cognito:groups → テナントID "SG-Sales" 特定                  │
│ 【ガバナンス制御】                                               │
│   ログ記録（テナントID・ユーザーID・トークン数）                 │
│   コスト配賦・将来のテナント別ガードレール対応                    │
│ 【ゲートウェイ・ルーティング】                                   │
│   モデルルーティング: UIモデル名 → Bedrock API                  │
│   KB部門フィルタ: department="SG-Sales" で検索                  │
└────────────────────────────────────────────────────────────────┘
            │                          │
            ▼                          ▼
    ┌────────────┐          ┌──────────────────────┐
    │  Bedrock   │          │ Knowledge Base       │
    │ (Claude等) │          │ (Aurora PostgreSQL)  │
    └────────────┘          └──────────────────────┘
```

### 提供API仕様

| API | 機能 | リクエスト例 | レスポンス |
|-----|------|------------|-----------|
| **POST /api/chat** | RAGチャット | `{ "message": "売上レポート", "model": "claude-3-5-sonnet" }`<br>Header: `Authorization: Bearer {JWT}` | ストリーミングレスポンス（SSE）<br>`{ "answer": "...", "sources": [...] }` |
| **POST /api/bedrock/invoke** | Bedrock直接呼び出し | `{ "prompt": "要約して", "model": "claude-3-haiku" }`<br>Header: `Authorization: Bearer {JWT}` | `{ "completion": "..." }` |
| **GET /api/documents** | ドキュメント一覧取得 | Header: `Authorization: Bearer {JWT}` | `[{ "id": "...", "title": "...", "department": "SG-Sales" }]` |

### ゲートウェイ実装例（Lambda）

```typescript
// Lambda: ChatGateway
export const handler = async (event: APIGatewayProxyEvent) => {
  // 1. JWT検証・テナントID抽出
  const claims = event.requestContext.authorizer!.claims;
  const groups = claims['cognito:groups'] || [];
  const tenantId = extractTenantId(groups); // "SG-Sales"
  const userId = claims['email'];

  // 2. リクエスト解析
  const { message, model } = JSON.parse(event.body!);

  // 3. ガバナンスログ記録
  console.log(JSON.stringify({
    timestamp: new Date().toISOString(),
    tenantId,           // ← テナントID埋め込み
    userId,
    action: 'chat',
    model,
    message: message.substring(0, 100), // プレビュー
  }));

  // 4. ナレッジベース検索（テナントフィルタリング）
  const retrieveResponse = await bedrock.send(new RetrieveCommand({
    knowledgeBaseId: process.env.KB_ID,
    retrievalQuery: { text: message },
    retrievalConfiguration: {
      vectorSearchConfiguration: {
        numberOfResults: 5,
        filter: {
          equals: {
            key: 'department',
            value: tenantId,  // ← テナント別フィルタリング
          },
        },
      },
    },
  }));

  // 5. Bedrock呼び出し（モデルルーティング）
  const invokeResponse = await bedrock.send(new InvokeModelCommand({
    modelId: model,  // ← UIで指定されたモデルを使用
    body: JSON.stringify({
      anthropic_version: 'bedrock-2023-05-31',
      messages: [{ role: 'user', content: message }],
      system: buildSystemPrompt(retrieveResponse.retrievalResults),
    }),
  }));

  // 6. トークン使用量記録（コスト配賦用）
  const usage = JSON.parse(invokeResponse.body).usage;
  console.log(JSON.stringify({
    timestamp: new Date().toISOString(),
    tenantId,           // ← テナントID埋め込み
    userId,
    model,
    inputTokens: usage.input_tokens,
    outputTokens: usage.output_tokens,
  }));

  return { statusCode: 200, body: JSON.stringify({ answer: '...' }) };
};
```

---

## 📊 高精度データ前処理パイプライン

### 機能概要

全社共通LLMゲートウェイ基盤のナレッジベースは、**Amazon Textract AI-OCR**による高精度なテキスト・表データ抽出と、**セマンティック境界認識チャンキング**により、従来のOCRでは困難だった複雑なレイアウト・表構造を含むドキュメントの高精度なRAG検索を実現します。

### Amazon Textract AI-OCRの特徴

| 機能 | 従来のOCR | **Amazon Textract（AI-OCR）** | 効果 |
|------|----------|-------------------------------|------|
| **表領域の読み取り** | セル構造を認識できず、テキストが混在。<br>例: `列1列2列3\n値1値2値3` | **セル構造・行列関係を完全に保持**。<br>例: `\| 列1 \| 列2 \| 列3 \|\n\|値1\|値2\|値3\|` | 表データを含むRAG検索で正確な回答が可能。財務諸表・仕様書・マニュアル等で威力を発揮。 |
| **レイアウト解析** | 段落・見出しの区別が困難。 | **見出し・段落・リスト構造を自動認識**。AIがドキュメント構造を理解。 | セマンティック境界認識チャンキングで文脈を保持。 |
| **複雑なPDF対応** | 2カラムレイアウト、図表混在で破綻。 | **2カラム・3カラムレイアウトを正しく認識**。図表とテキストを分離。 | 学術論文・技術資料・カタログ等の高精度処理。 |
| **手書き文字認識** | 対応不可。 | **手書き文字認識に対応**（英語・数字）。 | フォーム・申請書・アンケート等のデジタル化。 |
| **フォーム処理** | キー・バリュー抽出が困難。 | **フォーム内のキー・バリューペアを自動抽出**。<br>例: `氏名: 田中太郎` | 申請書・契約書等の構造化データ抽出。 |
| **精度** | 90%前後（条件により大幅低下） | **95%以上**（表領域でも高精度維持） | 人手による修正コストを大幅削減。 |

### Textract表読み取り例

**従来OCR**（構造が破壊される）:
```
製品名価格在庫ステータス
商品A1,000円50個在庫あり
商品B2,500円0個在庫切れ
商品C800円120個在庫あり
```

**Textract AI-OCR**（表構造を完全保持）:
```
| 製品名  | 価格      | 在庫  | ステータス |
|---------|-----------|-------|-----------|
| 商品A   | 1,000円   | 50個  | 在庫あり   |
| 商品B   | 2,500円   | 0個   | 在庫切れ   |
| 商品C   | 800円     | 120個 | 在庫あり   |
```

→ LLMが表構造を理解し、「在庫切れの商品は？」等の質問に正確に回答可能。

### データ前処理アーキテクチャ

```
┌──────────────────────────────────────────────────────────────┐
│       PDF & Document Processing to Vector Store               │
│                   (AWS Architecture)                           │
├──────────────────────────────────────────────────────────────┤
│                                                                │
│  [企業ネットワーク (Closed)]                                  │
│           │                                                    │
│           ▼                                                    │
│  ┌────────────────┐                                           │
│  │ PDF, Docs, etc │ ① アップロード                           │
│  └────────────────┘                                           │
│           │                                                    │
│           ▼                                                    │
│  ┌────────────────┐                                           │
│  │  S3 Bucket     │ ② 一時保存                               │
│  │  (Raw Docs)    │                                           │
│  └────────────────┘                                           │
│           │                                                    │
│           ▼                                                    │
│  ┌────────────────┐                                           │
│  │ Lambda:        │ ③ バリデーション                          │
│  │ Validation     │    - フォーマット検証（PDF/DOCX/TXT）     │
│  │ (Formats)      │    - ファイルサイズ制限                   │
│  └────────────────┘    - 部門ID検証                          │
│           │                                                    │
│           ▼                                                    │
│  ┌────────────────┐                                           │
│  │ Textract       │ ④ テキスト抽出（OCR）                    │
│  │ Text Extraction│    - PDFからテキスト抽出                  │
│  │ (OCR)          │    - レイアウト保持                       │
│  └────────────────┘                                           │
│           │                                                    │
│           ▼                                                    │
│  ┌────────────────┐                                           │
│  │ Lambda:        │ ⑤ チャンキング処理                        │
│  │ Text Chunking  │    - 2048トークン/チャンク                │
│  │ (2048 tokens)  │    - オーバーラップ: 512トークン          │
│  │ + Embedding    │    - セマンティック境界認識               │
│  └────────────────┘    - Bedrock Embeddings 呼び出し         │
│           │                                                    │
│           ▼                                                    │
│  ┌────────────────┐                                           │
│  │ Aurora         │ ⑥ ベクトル格納                            │
│  │ PostgreSQL     │    - pgvector 拡張                        │
│  │ (pgvector)     │    - HNSW インデックス                    │
│  │                │    - 部門別パーティション                 │
│  └────────────────┘                                           │
│           │                                                    │
│           ▼                                                    │
│  ┌────────────────┐                                           │
│  │ Knowledge Base │ ⑦ 検索API                                 │
│  │ API            │    - Bedrock Retrieve API                 │
│  └────────────────┘                                           │
│                                                                │
└──────────────────────────────────────────────────────────────┘
```

### ベクトルストレージ実装（Aurora PostgreSQL + pgvector）

ベクトルデータベースには、コスト最適化の観点から**Aurora PostgreSQL Serverless v2 + pgvector拡張**を採用します。

| 技術要素 | 実装内容 |
|---------|---------|
| **pgvector拡張** | Bedrock Embeddings（1536次元ベクトル）を格納。HNSW インデックスによる高速検索。 |
| **部門別フィルタ** | `department` カラムで部門ID（SG-Sales等）を管理し、テナント別データ分離を実現。 |
| **ハイブリッド検索** | ベクトル検索 + 全文検索 + メタデータ検索を組み合わせ。 |
| **パーティショニング** | 部門別テーブルパーティションにより大規模データに対応。 |

### チャンキング戦略

精密なチャンキング処理により、検索精度とコンテキスト維持のバランスを最適化します。

| チャンキング要素 | 設定値 | 効果 |
|----------------|-------|------|
| **チャンクサイズ** | 2048トークン/チャンク | Bedrock Claude の入力トークン制限（200k）に対して適切なサイズ。1チャンク = 約1,500〜2,000文字（日本語）。 |
| **オーバーラップ** | 512トークン | 前後のチャンクと25%重複。文脈の切断を防止し、段落またぎの検索精度を向上。 |
| **セマンティック境界認識** | 段落・見出し単位での分割 | 文章の意味的なまとまりを保持。正規表現で見出し（`#`, `##`, `第〇章`）や段落（`\n\n`）を検出し、不自然な位置での分割を回避。 |
| **親子関係保持** | `originalDocId` (親ドキュメント)<br>`extractedId` (子チャンク) | Knowledge Base API が前後のコンテキストを考慮した回答生成を可能にする。ファイル単位の親も保持（`fileId`）。 |
| **メタデータ付与** | `department`, `fileName`, `createdAt`, `author` | テナント別フィルタ、ファイル名検索、作成日フィルタリング等の高度な検索条件に対応。 |

### データ前処理Lambda実装例

```typescript
// Lambda: DocumentProcessing
import { TextractClient, AnalyzeDocumentCommand } from '@aws-sdk/client-textract';
import { BedrockRuntimeClient, InvokeModelCommand } from '@aws-sdk/client-bedrock-runtime';
import { S3Client, GetObjectCommand } from '@aws-sdk/client-s3';
import { RDSDataClient, ExecuteStatementCommand } from '@aws-sdk/client-rds-data';

export const handler = async (event: S3Event) => {
  const s3 = new S3Client({});
  const textract = new TextractClient({});
  const bedrock = new BedrockRuntimeClient({});
  const rds = new RDSDataClient({});

  // 1. S3からPDFファイル取得
  const bucket = event.Records[0].s3.bucket.name;
  const key = decodeURIComponent(event.Records[0].s3.object.key);
  const department = key.split('/')[1]; // s3://bucket/SG-Sales/file.pdf

  console.log(JSON.stringify({ action: 'document-processing-start', department, fileName: key }));

  // 2. Textractでテキスト・表データ抽出（AI-OCR）
  const textractResponse = await textract.send(new AnalyzeDocumentCommand({
    Document: { S3Object: { Bucket: bucket, Name: key } },
    FeatureTypes: ['TABLES', 'LAYOUT'], // ★ 表構造 + レイアウト認識
  }));

  // 2-1. 表データの抽出（セル構造を保持してMarkdown形式に変換）
  const tables = extractTables(textractResponse.Blocks || []);
  const tableTexts = tables.map(table => convertTableToMarkdown(table)).join('\n\n');

  // 2-2. 通常テキストの抽出（表以外）
  const textBlocks = textractResponse.Blocks
    ?.filter(b => b.BlockType === 'LINE' && !isInTable(b, tables))
    .map(b => b.Text)
    .join('\n') || '';

  // 2-3. 表データとテキストを結合
  const fullText = `${textBlocks}\n\n${tableTexts}`;

  // 3. チャンキング処理（セマンティック境界認識）
  const chunks = smartChunking(fullText, {
    maxTokens: 2048,
    overlapTokens: 512,
    respectBoundaries: true, // 段落・見出し単位での分割
  });

  // 4. 各チャンクをEmbedding + Aurora格納
  for (const [index, chunk] of chunks.entries()) {
    // 4-1. Bedrock Embeddings 呼び出し
    const embeddingResponse = await bedrock.send(new InvokeModelCommand({
      modelId: 'amazon.titan-embed-text-v1',
      body: JSON.stringify({ inputText: chunk.text }),
    }));
    const embedding = JSON.parse(embeddingResponse.body).embedding; // 1536次元ベクトル

    // 4-2. Aurora PostgreSQL へINSERT
    await rds.send(new ExecuteStatementCommand({
      resourceArn: process.env.AURORA_CLUSTER_ARN,
      secretArn: process.env.AURORA_SECRET_ARN,
      database: 'bedrock_integration',
      sql: `
        INSERT INTO bedrock_kb (
          id, department, file_name, chunk_index, chunks, embedding,
          original_doc_id, extracted_id, created_at, metadata
        ) VALUES (
          :id, :department, :fileName, :chunkIndex, :chunks, :embedding,
          :originalDocId, :extractedId, NOW(), :metadata
        )
      `,
      parameters: [
        { name: 'id', value: { stringValue: `${key}-${index}` } },
        { name: 'department', value: { stringValue: department } },
        { name: 'fileName', value: { stringValue: key.split('/').pop() } },
        { name: 'chunkIndex', value: { longValue: index } },
        { name: 'chunks', value: { stringValue: chunk.text } },
        { name: 'embedding', value: { stringValue: `[${embedding.join(',')}]` } },
        { name: 'originalDocId', value: { stringValue: key } },
        { name: 'extractedId', value: { stringValue: `${key}-${index}` } },
        { name: 'metadata', value: { stringValue: JSON.stringify(chunk.metadata) } },
      ],
    }));
  }

  console.log(JSON.stringify({
    action: 'document-processing-complete',
    department,
    fileName: key,
    totalChunks: chunks.length,
  }));
};

// スマートチャンキング関数（セマンティック境界認識）
function smartChunking(text: string, options: {
  maxTokens: number;
  overlapTokens: number;
  respectBoundaries: boolean;
}): Array<{ text: string; metadata: any }> {
  // 見出しパターン（Markdown形式、章番号等）
  const headingPatterns = /^(#{1,6}\s+|第[0-9]+章\s+|[0-9]+\.\s+)/gm;

  // 段落境界（2つ以上の改行）
  const paragraphs = text.split(/\n\n+/);

  const chunks: Array<{ text: string; metadata: any }> = [];
  let currentChunk = '';
  let currentTokens = 0;

  for (const paragraph of paragraphs) {
    const paragraphTokens = estimateTokens(paragraph); // トークン数推定

    if (currentTokens + paragraphTokens > options.maxTokens) {
      // チャンク確定
      if (currentChunk) {
        chunks.push({ text: currentChunk, metadata: { boundary: 'semantic' } });
      }

      // オーバーラップ領域を次のチャンクの先頭に含める
      const overlapText = currentChunk.slice(-options.overlapTokens * 4); // 概算: 1トークン≈4文字
      currentChunk = overlapText + '\n\n' + paragraph;
      currentTokens = estimateTokens(currentChunk);
    } else {
      currentChunk += (currentChunk ? '\n\n' : '') + paragraph;
      currentTokens += paragraphTokens;
    }
  }

  // 最後のチャンク
  if (currentChunk) {
    chunks.push({ text: currentChunk, metadata: { boundary: 'semantic' } });
  }

  return chunks;
}

function estimateTokens(text: string): number {
  // 日本語・英語混在の簡易トークン数推定
  // 実際にはtiktokenライブラリ等を使用
  return Math.ceil(text.length / 3); // 概算: 3文字≈1トークン
}

// ★ Textract 表データ抽出ヘルパー関数
interface TextractBlock {
  BlockType?: string;
  Id?: string;
  Relationships?: Array<{ Type?: string; Ids?: string[] }>;
  Text?: string;
  RowIndex?: number;
  ColumnIndex?: number;
}

function extractTables(blocks: TextractBlock[]): Array<{ cells: Map<string, string> }> {
  const tables: Array<{ cells: Map<string, string> }> = [];
  const blockMap = new Map(blocks.map(b => [b.Id!, b]));

  for (const block of blocks) {
    if (block.BlockType === 'TABLE') {
      const cells = new Map<string, string>(); // key: "row-col", value: cell text
      const cellIds = block.Relationships?.find(r => r.Type === 'CHILD')?.Ids || [];

      for (const cellId of cellIds) {
        const cell = blockMap.get(cellId);
        if (cell?.BlockType === 'CELL') {
          const rowIndex = cell.RowIndex || 0;
          const colIndex = cell.ColumnIndex || 0;
          const cellText = getCellText(cell, blockMap);
          cells.set(`${rowIndex}-${colIndex}`, cellText);
        }
      }

      tables.push({ cells });
    }
  }

  return tables;
}

function getCellText(cell: TextractBlock, blockMap: Map<string, TextractBlock>): string {
  const wordIds = cell.Relationships?.find(r => r.Type === 'CHILD')?.Ids || [];
  return wordIds
    .map(id => blockMap.get(id)?.Text || '')
    .join(' ')
    .trim();
}

function convertTableToMarkdown(table: { cells: Map<string, string> }): string {
  // セル位置から行数・列数を計算
  const positions = Array.from(table.cells.keys()).map(key => {
    const [row, col] = key.split('-').map(Number);
    return { row, col };
  });
  const maxRow = Math.max(...positions.map(p => p.row));
  const maxCol = Math.max(...positions.map(p => p.col));

  // Markdown形式の表を生成
  let markdown = '';
  for (let row = 1; row <= maxRow; row++) {
    const rowCells: string[] = [];
    for (let col = 1; col <= maxCol; col++) {
      rowCells.push(table.cells.get(`${row}-${col}`) || '');
    }
    markdown += '| ' + rowCells.join(' | ') + ' |\n';

    // ヘッダー行の下に区切り線を追加
    if (row === 1) {
      markdown += '|' + Array(maxCol).fill('---').join('|') + '|\n';
    }
  }

  return markdown;
}

function isInTable(block: TextractBlock, tables: Array<{ cells: Map<string, string> }>): boolean {
  // 表内のテキストブロックかどうかを判定（簡易実装）
  // 実際にはブロックIDの親子関係をチェック
  return false; // 詳細実装は省略
}
```

### 開発・設定作業の分類と工数

#### AWS標準機能（設定のみ）

| カテゴリ | サービス | 設定作業 | 工数見積 |
|---------|---------|---------|---------|
| **ナレッジベース基盤** | Aurora PostgreSQL Serverless v2<br>pgvector拡張<br>Bedrock Knowledge Base | Aurora クラスター作成、pgvector拡張有効化、Knowledge Base設定、Data Source（S3）連携 | **5人日** |
| **データ取り込み** | S3 Bucket<br>EventBridge<br>Textract | S3バケット作成、イベント通知設定、Textract 統合 | **2人日** |

**AWS標準機能 小計**: **7人日**

#### 当社カスタム開発

| カテゴリ | 開発要素 | 使用技術 | 工数見積 |
|---------|---------|---------|---------|
| **データ前処理パイプライン** | | | **18人日** |
| ├ Lambda（DocumentValidation） | フォーマット検証、ファイルサイズ制限、部門ID検証 | TypeScript, AWS SDK | 3人日 |
| ├ Lambda（DocumentProcessing） | Textract連携、チャンキング処理、Embeddings呼び出し、Aurora格納 | TypeScript, AWS SDK, Bedrock SDK | 8人日 |
| ├ Lambda（DocumentDeletion） | チャンク削除、インデックス更新 | TypeScript, AWS SDK | 2人日 |
| ├ インフラ（CDK）- Aurora | テーブル設計、インデックス設計、パーティショニング設定 | CDK (TypeScript), SQL | 3人日 |
| └ インフラ（CDK）- EventBridge | S3イベント→Lambda トリガー設定 | CDK (TypeScript) | 2人日 |

**当社カスタム開発 小計**: **18人日**

---

**データ前処理パイプライン工数**: **約25人日**（AWS標準機能設定 7人日 + 当社カスタム開発 18人日）

---

## 📊 ガバナンス機能

### テナントID埋め込みによる統制

| ガバナンス項目 | 実装内容 |
|--------------|---------|
| **ログ統制** | すべてのAPI呼び出しログに `tenantId` フィールドを埋め込み<br>→ CloudWatch Logs Insights でテナント別分析が可能<br>例: `fields @timestamp, tenantId, userId, model, inputTokens \| filter tenantId = "SG-Sales"` |
| **コスト配賦** | CloudWatch Logs → Metric Filter → CloudWatch Metrics<br>→ テナント別トークン使用量を自動集計<br>→ 部門別のLLM利用コストを可視化 |
| **アクセス制御** | JWTの `cognito:groups` を検証し、テナント外のリソースへのアクセスを拒否<br>例: User-SG-Sales は SG-Marketing のドキュメントにアクセス不可 |
| **監査証跡** | すべてのリクエスト・レスポンスをテナントIDと紐付けて保存<br>→ コンプライアンス監査に対応 |

### 将来拡張: テナント別ガードレール

```typescript
// 将来実装例: テナント別ガードレール設定
const guardrailConfig = await getGuardrailConfig(tenantId);

if (guardrailConfig.enabled) {
  const applyGuardrailResponse = await bedrock.send(new ApplyGuardrailCommand({
    guardrailIdentifier: guardrailConfig.guardrailId,
    guardrailVersion: guardrailConfig.version,
    source: 'INPUT',
    content: [{ text: { text: message } }],
  }));

  if (applyGuardrailResponse.action === 'GUARDRAIL_INTERVENED') {
    // ガードレール違反: リクエスト拒否
    return {
      statusCode: 400,
      body: JSON.stringify({
        error: 'このリクエストは部門のガードレールポリシーに違反しています',
        details: applyGuardrailResponse.assessments,
      }),
    };
  }
}
```

### テナント別ガードレール設定例

| テナント | 制限内容 | 設定値 |
|---------|---------|-------|
| **SG-Sales（営業部）** | ・顧客情報の漏洩防止<br>・競合他社名の出力制限 | Guardrail ID: `営業部専用ガードレール`<br>- Sensitive Information Filter: 有効<br>- Denied Topics: ["競合情報"] |
| **SG-Legal（法務部）** | ・法的助言の禁止<br>・機密性の高い契約情報の保護 | Guardrail ID: `法務部専用ガードレール`<br>- Content Filter: 高<br>- Denied Topics: ["法的助言"] |
| **SG-HR（人事部）** | ・個人情報保護<br>・給与・評価情報の制限 | Guardrail ID: `人事部専用ガードレール`<br>- PII Redaction: 有効<br>- Denied Topics: ["給与", "評価"] |

---

## 🎯 全社共通基盤としての価値

### 疎結合アーキテクチャによる柔軟性

| メリット | 説明 |
|---------|------|
| **LLMモデルの変更が容易** | チャットアプリは単一のAPIエンドポイントを呼ぶだけ。LLMゲートウェイ側でモデルを切り替えても、フロントエンド変更不要。 |
| **ナレッジベース実装の変更が容易** | 現在はAurora PostgreSQL（pgvector）を使用しているが、将来OpenSearch Serverlessに移行しても、API仕様は変わらない。 |
| **新機能の段階的展開** | 特定テナントのみで新しいガードレールや機能を試験運用し、全社展開前に検証可能。 |

### ガバナンス一元化による統制

| メリット | 説明 |
|---------|------|
| **コンプライアンス対応** | すべてのLLM利用がゲートウェイを経由するため、監査証跡が完全。 |
| **コスト可視化** | テナント別・ユーザー別・モデル別のトークン使用量を自動集計。 |
| **セキュリティ統制** | ガードレール、アクセス制御、データフィルタリングをゲートウェイで一元管理。 |

---

## 🔒 非機能要件への対応

### セキュリティ・ガバナンスアーキテクチャ概要

全社共通LLMゲートウェイ基盤は、**閉域接続とゼロトラストアーキテクチャ**を採用し、8つのセキュリティアンチパターンへの対応を組み込んだ、エンタープライズグレードのセキュアなインフラ基盤です。

```
┌──────────────────────────────────────────────────────────────┐
│               Secure Closed Network Architecture              │
├──────────────────────────────────────────────────────────────┤
│                                                                │
│  [企業ネットワーク] → [Transit Gateway] → [Secure AWS VPC]   │
│                                ↓                               │
│                         [Web Apps Gateway]                     │
│                                ↓                               │
│                    [PrivateLink + Security Group]              │
│                                ↓                               │
│           [Bedrock / Aurora KB / S3 / CloudWatch]             │
│                                                                │
│  ■ セキュリティ設定:                                          │
│    - VPCエンドポイント (PrivateLink): インターネット経由なし │
│    - Security Group: 最小権限の原則に基づくアクセス制御       │
│    - NACL: サブネットレベルのファイアウォール                 │
│    - Transit Gateway: 複数VPC間の安全な通信                   │
│    - WAF: Web Application Firewall によるL7攻撃防御           │
│                                                                │
└──────────────────────────────────────────────────────────────┘
```

---

### 包括的モニタリング戦略

| カテゴリ | AWSサービス | 当社対応方針 | 開発・設定作業 |
|---------|-----------|------------|---------------|
| **ログ/監査** | CloudTrail<br>CloudWatch Logs<br>Config | ✅ **AWS標準機能（設定のみ）** | **インフラ設定（CDK）**: 3人日<br>- CloudTrail 証跡設定（S3保存）<br>- CloudWatch Logs グループ作成<br>- Config ルール設定（リソース変更追跡）<br>- ログ保持期間設定（監査要件対応） |
| **モニタリング/アラート** | CloudWatch<br>GuardDuty<br>Security Hub | ✅ **AWS標準機能（設定のみ）** | **インフラ設定（CDK）**: 2人日<br>- CloudWatch メトリクス・アラーム設定<br>- GuardDuty 有効化（脅威検出）<br>- Security Hub 有効化（セキュリティ統合）<br>- SNS 通知設定（アラート配信） |
| **統合分析** | Security Lake<br>SIEM統合 | ⚠️ **標準で統合可能** | **オプション**: 将来拡張<br>- CloudWatch Logs → Splunk/SIEM統合<br>- Security Lake データレイク構築<br>- S3バケットのログ統合設定 |

---

### ネットワークセキュリティ

| 機能 | AWSサービス | 当社対応方針 | 開発・設定作業 |
|------|-----------|------------|---------------|
| **DDoS対策** | AWS Shield Standard | ✅ **AWS標準機能（自動適用）** | **設定不要**<br>- 全AWSリソースに自動適用<br>- L3/L4 DDoS攻撃を自動防御 |
| **WAF** | AWS WAF | ✅ **AWS Managed Rules** | **インフラ設定（CDK）**: 2人日<br>- ALB/API Gateway にWAF設定<br>- AWS Managed Rules (Core, SQL Injection) 適用<br>- カスタムルール設定（レート制限） |
| **プライベート接続** | PrivateLink<br>VPCエンドポイント | ✅ **AWS標準機能（設定のみ）** | **インフラ設定（CDK）**: 3人日<br>- VPCエンドポイント作成（Bedrock, S3, DynamoDB等）<br>- PrivateLink 接続設定<br>- インターネットゲートウェイなし構成 |
| **ネットワーク分離** | VPC<br>Security Group<br>NACL<br>Transit Gateway | ✅ **AWS標準機能（設定のみ）** | **インフラ設定（CDK）**: 5人日<br>- VPC サブネット設計（Public/Private分離）<br>- Security Group 設定（最小権限）<br>- NACL 設定（サブネット間制御）<br>- Transit Gateway 設定（複数VPC統合） |

---

### 8つのセキュリティアンチパターンへの対応

| アンチパターン | 対応AWSサービス | 当社対応方針 | 開発・設定作業 |
|--------------|---------------|------------|---------------|
| **1. 認証/アクセス制御の欠如** | IAM<br>IAM Identity Center<br>Cognito | ✅ **開発必要** | **本提案の認証・認可システム**<br>- Cognito + Entra ID SAML連携<br>- マルチテナントリゾルバ実装<br>- IAM Role マッピング<br>→ **55人日**（管理者登録フロー含む） |
| **2. 人力リソース不足** | Bedrock Guardrails<br>WAF<br>Shield | ✅ **AWS Managed + 将来拡張** | **インフラ設定（CDK）**: 2人日<br>- WAF Managed Rules 適用<br>- Shield Standard 自動適用<br>**将来拡張**: テナント別Guardrails設定 |
| **3. 安全でない通信** | PrivateLink<br>ACM<br>TLS 1.2以上 | ✅ **AWS標準機能（設定のみ）** | **インフラ設定（CDK）**: 2人日<br>- AWS Certificate Manager (ACM) 証明書取得<br>- ALB/API Gateway に TLS 1.2以上設定<br>- PrivateLink 経由の暗号化通信 |
| **4. ログ/監査不十分** | CloudTrail<br>CloudWatch Logs<br>Config | ✅ **AWS標準機能（設定のみ）**<br>✅ **開発必要（ゲートウェイログ）** | **インフラ設定（CDK）**: 3人日<br>- 上記「包括的モニタリング戦略」参照<br>**Lambda実装**: **含む**（LLMゲートウェイ）<br>- すべてのAPI呼び出しログに<br>  テナントID埋め込み |
| **5. データストレージ不安全** | KMS<br>Aurora 暗号化<br>S3 暗号化 | ✅ **AWS標準機能（設定のみ）** | **インフラ設定（CDK）**: 2人日<br>- KMS カスタマーマネージドキー作成<br>- Aurora: Encryption at Rest 有効化<br>- S3: SSE-KMS 暗号化設定<br>- DynamoDB: 暗号化有効化 |
| **6. FM/AI安全性欠如** | Bedrock Guardrails<br>OpenSearch | ✅ **将来拡張** | **将来実装**<br>- Guardrails の PII Redaction 設定<br>- 有害コンテンツフィルタリング<br>- 安全なコンテンツ生成ポリシー |
| **7. AI/PIバイアス/公平性欠如** | Bedrock Guardrails<br>CloudWatch | ✅ **将来拡張** | **将来実装**<br>- Guardrails の Bias Detection 機能<br>- CloudWatch でバイアス指標監視<br>- マスク入力機能によるPII保護 |
| **8. テスト/検証不十分** | Inspector<br>Security Hub | ✅ **AWS標準機能（設定のみ）** | **インフラ設定（CDK）**: 1人日<br>- Amazon Inspector (ECR/Lambda スキャン)<br>- Security Hub 統合（脆弱性一元管理）<br>- リソース自動テスト・検証 |

---

### 開発・設定作業の分類と工数

#### AWS標準機能（設定のみ）

| カテゴリ | サービス | 設定作業 | 工数見積 |
|---------|---------|---------|---------|
| **セキュリティインフラ** | VPC, Security Group, NACL, PrivateLink, TGW, WAF, Shield, ACM | VPC設計、SG/NACL設定、PrivateLink接続、WAF Managed Rules、TLS証明書 | **15人日** |
| **モニタリング/ログ** | CloudTrail, CloudWatch, Logs, Config, GuardDuty, Security Hub, Inspector | 証跡設定、ログ保持、アラーム設定、脅威検出、セキュリティスキャン | **6人日** |
| **データ暗号化** | KMS, Aurora Encryption, S3 Encryption, DynamoDB Encryption | CMK作成、Encryption at Rest有効化、SSE-KMS設定 | **2人日** |
| **ナレッジベース基盤** | Aurora PostgreSQL Serverless v2<br>pgvector拡張<br>Bedrock Knowledge Base | Aurora クラスター作成、pgvector拡張有効化、Knowledge Base設定、Data Source（S3）連携 | **5人日** |
| **データ取り込み** | S3 Bucket<br>EventBridge<br>Textract | S3バケット作成、イベント通知設定、Textract 統合 | **2人日** |

**AWS標準機能 小計**: **30人日**

#### 当社カスタム開発

| カテゴリ | 開発要素 | 使用技術 | 工数見積 |
|---------|---------|---------|---------|
| **認証・認可システム** | マルチテナントリゾルバ + 管理者登録フロー | Cognito, Lambda, S3, CDK | **55人日** |
| **LLMゲートウェイ** | 統合API + ルーティング + ガバナンスログ | API Gateway, Lambda, Bedrock SDK | **25人日** |
| **データ前処理パイプライン** | チャンキング + Embeddings + Aurora格納 | Lambda, Textract, Bedrock SDK, CDK | **18人日** |
| **フロントエンド** | チャットUI + 管理画面 | React, TypeScript | **20人日** |

**当社カスタム開発 小計**: **118人日**

---

**全体工数**: **約148人日**（AWS標準機能設定 30人日 + 当社カスタム開発 118人日）

---

## 📋 推奨フロー（マルチテナントリゾルバの文脈）

### ステップ0: 部門（テナント）の作成
```
1. システム管理者が管理画面で「新規部門作成」をクリック
2. 部門名（Entra IDのセキュリティグループ名）を入力: SG-Sales
3. 「作成」ボタンをクリック
   ↓ システムが自動処理
4. Cognitoグループ作成: Admin-SG-Sales（管理者用）
5. Cognitoグループ作成: User-SG-Sales（一般ユーザー用）
6. IAM Role 紐付け（それぞれのグループに適切な権限を設定）
```

### ステップ1: 部門管理者の登録
```
1. 管理画面で tanaka@isuzu.co.jp を SG-Sales（営業部）の管理者として登録
2. システムが S3 に JSON ファイル保存（s3://pending-assignments/tanaka@isuzu.co.jp.json）
   - groups: ["Admin-SG-Sales"]
3. 画面に「登録完了。ログインURLを共有してください」と表示
4. 業務メールで田中さんに通知（手動 or SES自動送信）
```

### ステップ2: 田中さん（部門管理者）の初回ログイン
```
1. メール受信 → URLクリック（https://llm-gateway.isuzu.co.jp）
2. 「Entra ID でログイン」ボタンをクリック
3. Entra ID で認証（既存アカウント・既存パスワード使用）
   ※ Entra IDから所属セキュリティグループ（SG-Sales）が渡される
4. 【自動処理】Cognito User Pool にユーザー自動作成
5. 【自動処理】Post Authentication Trigger 実行
   - S3 から JSON 読み取り → Admin-SG-Sales グループに追加 → S3 削除
6. 【自動処理】JWT発行（cognito:groups: ["Admin-SG-Sales"] を自動セット）
7. 管理画面が表示（管理者権限付与完了）
   ※ フロントエンドがJWTから管理者権限を判定
```

---

## 🔄 処理フロー詳細

### ステップ1: システム管理者が部門管理者を登録（未ログインユーザーの場合）

**前提**: 部門（SG-Sales）は既に作成済み（ステップ0で作成）

| No | 処理内容 | AWSサービス | SI開発要否 | 開発内容 | カテゴリ | 使用技術 | 工数 |
|----|---------|-----------|----------|---------|---------|---------|------|
| 1.1 | 管理者情報の入力と登録 | - | ✅ **開発必要** | **管理画面UI実装**<br>- メールアドレス入力フォーム作成<br>- 管理対象部門の選択UI（ドロップダウン: SG-Sales, SG-Marketing等）<br>- メール形式バリデーション<br>- 登録ボタンクリックイベント処理 | 管理画面UI<br>（システム管理者） | React<br>TypeScript<br>Material-UI | 3人日 |
| 1.2 | グループ割当処理 | API Gateway<br>Lambda<br>Cognito User Pool<br>S3 | ✅ **開発必要** | **バックエンド実装（Lambda + インフラ）**<br>- 前提: 部門作成時に以下の2つのCognitoグループが作成済み<br>  - Admin-{SecurityGroup}（管理者用）<br>  - User-{SecurityGroup}（一般ユーザー用）<br>- Lambda: ユーザー存在確認と処理分岐<br>- 既存ユーザー: 直接Admin-{SecurityGroup}に追加<br>- 未ログインユーザー: S3に保留情報を保存<br>- S3バケット作成と30日自動削除ポリシー設定 | API Gateway<br>+<br>Lambda<br>AssignPendingGroup<br>+<br>インフラ（CDK）<br>S3 | CDK<br>TypeScript<br>AWS SDK | 10人日 |
| 1.3 | 登録完了通知 | - | ✅ **開発必要** | **Lambda + フロントエンド実装**<br>- Lambda: JSON形式でステータス返却<br>- 画面: レスポンス受信後にトースト通知表示<br>- 「初回ログイン時に自動適用」メッセージ | Lambda + 管理画面UI | TypeScript<br>React | 含む |

**ステップ1 小計**: 管理画面UI 3人日 + バックエンド処理 10人日 = **13人日**

---

### ステップ2: 田中さんが初回ログイン

| No | 処理内容 | AWSサービス | SI開発要否 | 開発内容 | カテゴリ | 使用技術 | 工数 |
|----|---------|-----------|----------|---------|---------|---------|------|
| 2.1 | ログイン画面表示 | CloudFront<br>ALB, ECS<br>Cognito Hosted UI | ✅ / ❌ | **フロントエンド実装 + 設定**<br>- ログインページ作成とCognito Hosted UIへのリダイレクト処理<br>- Hosted UIのカスタマイズ（ロゴ・背景色） | 管理画面UI | React<br>TypeScript | 2人日 |
| 2.2 | SAML認証 | Entra ID (SAML) | ❌ **顧客側設定** | **設定作業のみ**<br>- Entra ID と Cognito 間のSAML連携設定<br>- メタデータXML交換<br>- 属性マッピング設定（email, name, セキュリティグループ等）<br>※ Entra IDから所属セキュリティグループ（SG-Sales等）が渡される | - | - | - |
| 2.3 | ユーザー自動作成 | Cognito User Pool | ❌ **AWS標準** | AWS標準機能（開発不要）<br>※ SAML認証成功時にCognitoが自動的にユーザー作成 | - | - | - |
| 2.4 | 保留情報の取得 | Lambda<br>(Cognito Trigger) | ✅ **開発必要** | **Lambda関数実装 + インフラ構築**<br>- S3から保留ファイル取得（メールアドレスをキーに検索）<br>- JSONデータのパース（例: ["Admin-SG-Sales"]）<br>- NoSuchKey例外のハンドリング<br>- Cognito Triggerの設定 | Lambda<br>PostAuthentication | TypeScript<br>AWS SDK | 3人日 |
| 2.5 | グループ自動追加 | Cognito User Pool<br>S3 | ✅ **開発必要** | **Lambda関数実装**<br>- 取得したグループリスト（例: Admin-SG-Sales）をループ処理<br>- 各グループにユーザーを追加<br>- 処理完了後にS3ファイルを削除<br>- エラーログ出力 | Lambda<br>PostAuthentication | TypeScript<br>AWS SDK | 2人日 |
| 2.6 | JWT発行 | Cognito User Pool | ❌ **AWS標準** | **AWS標準機能（開発不要）**<br>※ Cognitoが自動的に `cognito:groups` にグループ情報をセット<br>例: `{"cognito:groups": ["Admin-SG-Sales"]}` | - | - | - |
| 2.7 | トークン取得と画面表示 | - | ✅ **開発必要** | **フロントエンド実装**<br>- コールバックURLでAuthorization Code受信<br>- Token エンドポイントへPOSTリクエスト<br>- 取得したToken をLocalStorageに保存<br>- JWTから管理者権限を判定（cognito:groupsを参照）<br>- ホーム画面へリダイレクト処理 | 管理画面UI | React<br>TypeScript | 3人日 |

**ステップ2 小計**: 管理画面UI 5人日 + Lambda (PostAuthentication) 5人日 = **10人日**

---

### ステップ3: 部門管理者が一般ユーザーを登録

| No | 処理内容 | AWSサービス | SI開発要否 | 開発内容 | カテゴリ | 使用技術 | 工数 |
|----|---------|-----------|----------|---------|---------|---------|------|
| 3.1 | ユーザー管理画面 | Cognito Identity Pool<br>Cognito User Pool | ✅ **開発必要** | **フロントエンド実装**<br>- 「ユーザー管理」メニューの表示制御（管理者のみ）<br>- Identity Pool から一時認証情報を取得<br>- AdminListUsersInGroup API でユーザー一覧取得<br>- ユーザー一覧のテーブル表示UI<br>- ページネーション実装 | 管理画面UI<br>（部門管理者） | React<br>TypeScript<br>AWS SDK | 7人日 |
| 3.2 | ユーザー追加 | API Gateway<br>Lambda | ✅ **開発必要** | **フロントエンド実装**<br>- メールアドレス入力フォーム<br>- バリデーション処理<br>- API呼び出し（既存AssignPendingGroup再利用）<br>- 追加完了後のユーザー一覧再読み込み | 管理画面UI<br>（部門管理者） | React<br>TypeScript | 5人日 |
| 3.3 | 一般ユーザーへのメール通知 | Lambda<br>Amazon SES | ✅ **開発必要** | **Lambda + SES実装**<br>- ユーザー追加成功後に自動メール送信<br>- メールテンプレート作成（ログインURL含む）<br>- 送信ドメイン認証設定<br>※ 一般ユーザーはメール受信後、URL（https://llm-gateway.isuzu.co.jp）をクリックしてEntra ID認証を行い、初回ログイン時に自動的にUser-{SecurityGroup}に追加される | Lambda<br>SendNotification | TypeScript<br>AWS SDK<br>SES | 3人日 |

**ステップ3 小計**: 管理画面UI（部門管理者）12人日 + メール通知 3人日 = **15人日**

---

### ステップ0: 部門（テナント）作成機能

| No | 処理内容 | AWSサービス | SI開発要否 | 開発内容 | カテゴリ | 使用技術 | 工数 |
|----|---------|-----------|----------|---------|---------|---------|------|
| 0.1 | 部門作成UI | - | ✅ **開発必要** | **管理画面UI実装**<br>- 部門名入力フォーム（例: SG-Sales）<br>- 作成ボタンクリック処理<br>- バリデーション（重複チェック） | 管理画面UI<br>（システム管理者） | React<br>TypeScript | 2人日 |
| 0.2 | Cognitoグループ動的作成 | Lambda<br>Cognito User Pool | ✅ **開発必要** | **Lambda関数実装**<br>- Cognitoグループ作成（Admin-{SecurityGroup}）<br>- Cognitoグループ作成（User-{SecurityGroup}）<br>- IAM Role紐付け<br>- エラーハンドリング（既存グループ重複） | Lambda<br>CreateTenant | TypeScript<br>AWS SDK | 5人日 |

**ステップ0 小計**: **7人日**

### インフラ（Cognito初期設定）

| 項目 | 内容 | SI開発要否 | 開発内容 | カテゴリ | 使用技術 | 工数 |
|------|------|----------|---------|---------|---------|------|
| Cognito 初期設定 | - User Pool 作成<br>- SystemAdmin グループ作成<br>- IAM Role 定義<br>- SAML Identity Provider 設定<br>- User Pool Client 設定<br>- Identity Pool 作成 | ✅ **開発必要** | **インフラ構築**<br>- Cognito User Pool の作成<br>- SystemAdmin グループ作成（初期グループ）<br>- 管理者用/一般ユーザー用 IAM Role定義<br>- SAML Identity Provider（Entra ID）設定<br>- OAuth 2.0 設定（Authorization Code Flow）<br>- Identity Pool作成とRole Attachment設定<br>※ 部門別グループ（Admin-*, User-*）は動的作成 | インフラ（CDK）<br>Cognito | CDK<br>TypeScript | 8人日 |

---

## 📊 開発工数まとめ

### 当社カスタム開発

| カテゴリ | 開発要素 | 使用技術 | 工数見積 |
|---------|---------|---------|---------|
| **認証・認可システム** | | | **55人日** |
| ├ 管理画面UI（システム管理者） | 部門作成UI、部門管理者登録、メール入力フォーム、部門選択 | React, TypeScript, Material-UI | 12人日 |
| ├ 管理画面UI（部門管理者） | ユーザー一覧表示、新規ユーザー追加、Identity Pool 連携 | React, TypeScript, AWS SDK | 12人日 |
| ├ Lambda（CreateTenant） | Cognitoグループ動的作成、IAM Role 紐付け | TypeScript, AWS SDK | 5人日 |
| ├ Lambda（AssignPendingGroup） | Cognito 存在確認、S3 保存/直接追加分岐 | TypeScript, AWS SDK | 5人日 |
| ├ Lambda（PostAuthentication） | S3 読み取り、グループ自動追加、S3 削除 | TypeScript, AWS SDK | 5人日 |
| ├ Lambda（SendNotification） | メール送信、メールテンプレート、SES設定 | TypeScript, AWS SDK, SES | 3人日 |
| ├ インフラ（CDK）- S3 | pending-assignments バケット、ライフサイクルポリシー | CDK (TypeScript) | 2人日 |
| ├ インフラ（CDK）- API Gateway | エンドポイント定義、Cognito Authorizer | CDK (TypeScript) | 3人日 |
| └ インフラ（CDK）- Cognito | User Pool、SystemAdmin グループ、IAM Role マッピング、SAML 連携 | CDK (TypeScript) | 8人日 |
| **LLMゲートウェイ** | 統合API、ルーティング、ガバナンスログ | API Gateway, Lambda, Bedrock SDK | **25人日** |
| **データ前処理パイプライン** | | | **18人日** |
| ├ Lambda（DocumentValidation） | フォーマット検証、ファイルサイズ制限、部門ID検証 | TypeScript, AWS SDK | 3人日 |
| ├ Lambda（DocumentProcessing） | Textract連携、チャンキング処理、Embeddings呼び出し、Aurora格納 | TypeScript, AWS SDK, Bedrock SDK | 8人日 |
| ├ Lambda（DocumentDeletion） | チャンク削除、インデックス更新 | TypeScript, AWS SDK | 2人日 |
| ├ インフラ（CDK）- Aurora | テーブル設計、インデックス設計、パーティショニング設定 | CDK (TypeScript), SQL | 3人日 |
| └ インフラ（CDK）- EventBridge | S3イベント→Lambda トリガー設定 | CDK (TypeScript) | 2人日 |
| **フロントエンド** | チャットUI、管理画面 | React, TypeScript | **20人日** |

**当社カスタム開発 小計**: **118人日**

### AWS標準機能（設定のみ）

| カテゴリ | サービス | 設定作業 | 工数見積 |
|---------|---------|---------|---------|
| **セキュリティインフラ** | VPC, Security Group, NACL, PrivateLink, TGW, WAF, Shield, ACM | VPC設計、SG/NACL設定、PrivateLink接続、WAF Managed Rules、TLS証明書 | **15人日** |
| **モニタリング/ログ** | CloudTrail, CloudWatch, Logs, Config, GuardDuty, Security Hub, Inspector | 証跡設定、ログ保持、アラーム設定、脅威検出、セキュリティスキャン | **6人日** |
| **データ暗号化** | KMS, Aurora Encryption, S3 Encryption, DynamoDB Encryption | CMK作成、Encryption at Rest有効化、SSE-KMS設定 | **2人日** |
| **ナレッジベース基盤** | Aurora PostgreSQL Serverless v2<br>pgvector拡張<br>Bedrock Knowledge Base | Aurora クラスター作成、pgvector拡張有効化、Knowledge Base設定、Data Source（S3）連携 | **5人日** |
| **データ取り込み** | S3 Bucket<br>EventBridge<br>Textract | S3バケット作成、イベント通知設定、Textract 統合 | **2人日** |

**AWS標準機能 小計**: **30人日**

---

**全体工数**: **約148人日**（当社カスタム開発 118人日 + AWS標準機能設定 30人日）

---

## 🔐 重要ポイント

| 項目 | 内容 |
|------|------|
| **テナント管理** | 部門 = Entra IDセキュリティグループ = テナントID<br>例: 営業部（SG-Sales）、マーケ部（SG-Marketing） |
| **Cognitoグループ** | 各部門に対して `Admin-{SecurityGroup}` と `User-{SecurityGroup}` を動的作成<br>例: Admin-SG-Sales, User-SG-Sales |
| **権限管理** | Cognito側で管理者/一般ユーザーを区別（Entra IDからは所属部門のみ受信） |
| **JWT自動セット** | ✅ Cognitoが `cognito:groups` に所属グループを自動的に含める（開発不要）<br>例: `{"cognito:groups": ["Admin-SG-Sales", "User-SG-Marketing"]}` |
| **管理者判定** | フロントエンドでJWTの `cognito:groups` から判定（API不要）<br>`groups.filter(g => g.startsWith('Admin-'))` |
| **Cognito招待メール** | ❌ **送られません**（Cognitoにユーザーを事前作成していない、SAML連携でパスワード不要） |
| **SAML連携でCognito標準招待メールが使えない理由** | Cognito User Poolには **Native User**（`AdminCreateUser`で事前作成）と **Federated User**（SAML初回ログイン時に自動作成）の2種類が存在。`AdminCreateUser`でNative Userを作成すると、同じメールアドレスでSAMLログインした際に別のFederated Userが自動作成され、**同一人物が2つのアカウント**を持つことになる。グループ割り当てが分離し、正常に動作しない。<br><br>✅ **採用アプローチ**: S3保留 + カスタムメール通知（Lambda + Amazon SES）<br>- Cognitoにユーザーを事前作成しない<br>- S3にグループ割り当て情報を保存<br>- 初回SAML認証時に自動的にFederated User作成 + グループ追加 |
| **新しいパスワード** | ❌ **不要**（Entra IDのパスワードを使用） |
| **権限付与タイミング** | 初回ログイン時に自動（Post Authentication Trigger） |
| **DynamoDB** | ❌ **不使用**（S3 JSON ファイル方式） |
| **S3 ライフサイクル** | 30日で自動削除 |
| **マルチテナント対応** | 1ユーザが複数部門の管理者/一般ユーザーになることが可能 |

---

## 🏗️ AWSネイティブ機能（開発不要）

| 機能 | 使用サービス |
|------|------------|
| SAML 2.0 認証 | Cognito User Pool + Entra ID |
| JWT 発行・検証 | Cognito User Pool |
| OAuth 2.0 Authorization Code Flow | Cognito User Pool |
| グループメンバーシップ管理 | Cognito User Pool |
| IAM Role 一時認証情報発行 | Cognito Identity Pool |

---

## 📈 データフロー図

```
【ステップ0: 部門作成】
[システム管理者] → [React管理画面] → [Lambda: CreateTenant]
                                      ↓
                                [Cognito] グループ作成
                                - Admin-SG-Sales
                                - User-SG-Sales
                                      ↓
                                [IAM Role 紐付け]

【ステップ1: 部門管理者登録】
[システム管理者] → [React管理画面] → [API Gateway] → [Lambda: AssignPendingGroup]
                                           ↓
                                      [Cognito] AdminGetUser → UserNotFoundException
                                           ↓
                                      [S3] tanaka@isuzu.co.jp.json 保存
                                      {
                                        "email": "tanaka@isuzu.co.jp",
                                        "groups": ["Admin-SG-Sales"]
                                      }

【ステップ2: 初回ログイン】
[田中さん] → [Cognito Hosted UI] → [Entra ID SAML認証]
                                      ↓ セキュリティグループ（SG-Sales）を渡す
                                   [Cognito] ユーザー作成
                                      ↓
                                   [Lambda: PostAuthentication (Trigger)]
                                   S3読取 → AdminAddUserToGroup(Admin-SG-Sales) → S3削除
                                      ↓
                                   [JWT発行] ← Cognitoが自動セット
                                   {
                                     "cognito:groups": ["Admin-SG-Sales"],
                                     "email": "tanaka@isuzu.co.jp"
                                   }
                                      ↓
                                   [React管理画面]
                                   JWT解析 → Admin-* 判定 → 管理者メニュー表示
```

---

**作成者**: SI開発チーム | **最終更新**: 2025-12-12 | **バージョン**: 7.0（統合版：高精度データ前処理パイプライン追加）
